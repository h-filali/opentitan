// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include "sw/device/tests/penetrationtests/firmware/sca/ml_dsa_sca.h"

#include "sw/device/lib/base/memory.h"
#include "sw/device/lib/base/status.h"
#include "sw/device/lib/crypto/drivers/otbn.h"
#include "sw/device/lib/dif/dif_otbn.h"
#include "sw/device/lib/runtime/log.h"
#include "sw/device/lib/testing/test_framework/check.h"
#include "sw/device/lib/testing/test_framework/ottf_test_config.h"
#include "sw/device/lib/testing/test_framework/ujson_ottf.h"
#include "sw/device/lib/ujson/ujson.h"
#include "sw/device/sca/lib/prng.h"
#include "sw/device/tests/penetrationtests/firmware/lib/pentest_lib.h"
#include "sw/device/tests/penetrationtests/json/ml_dsa_sca_commands.h"

#include "hw/top_earlgrey/sw/autogen/top_earlgrey.h"

#define VECTOR_SIZE 256
#define MAX_BATCH_SIZE 32
#define MODULUS 8380417

// NOP macros.
#define NOP1 "addi x0, x0, 0\n"
#define NOP10 NOP1 NOP1 NOP1 NOP1 NOP1 NOP1 NOP1 NOP1 NOP1 NOP1
#define NOP30 NOP10 NOP10 NOP10

// Vector NTT
OTBN_DECLARE_APP_SYMBOLS(ml_dsa_ntt);
OTBN_DECLARE_SYMBOL_ADDR(ml_dsa_ntt, ntt_w);
const otbn_app_t kOtbnAppMlDsaNtt = OTBN_APP_T_INIT(ml_dsa_ntt);
static const otbn_addr_t kOtbnAppMlDsaNttW =
    OTBN_ADDR_T_INIT(ml_dsa_ntt, ntt_w);

// OTTF_DEFINE_TEST_CONFIG();

/**
 * The otbn context handler.
 */
static dif_otbn_t otbn;

// Generate Fixed vs Random (FvsR) array of values. The fixed value is provided
// by the user and the random values are generated by the PRNG provided in the
// SCA library.
static void generate_fvsr(size_t num_iterations, uint32_t fixed_data,
                          uint32_t values[MAX_BATCH_SIZE]) {
  bool sample_fixed = prng_rand_uint32() & 0x1;
  for (size_t i = 0; i < num_iterations; i++) {
    if (sample_fixed) {
      values[i] = fixed_data;
    } else {
      values[i] = prng_rand_uint32() % MODULUS;
    }
    sample_fixed = prng_rand_uint32() & 0x1;
  }
}

// Generate Fixed vs Random (FvsR) array of values. The fixed value is provided
// by the user and the random values are generated by the PRNG provided in the
// SCA library.
static void generate_vec_fvsr(size_t num_iterations, uint32_t fixed_data[],
                              uint32_t values[MAX_BATCH_SIZE][VECTOR_SIZE]) {
  bool sample_fixed = prng_rand_uint32() & 0x1;
  for (size_t i = 0; i < num_iterations; i++) {
    if (sample_fixed) {
      for (size_t j = 0; j < VECTOR_SIZE; j++) {
        values[i][j] = fixed_data[j];
      }
    } else {
      for (size_t j = 0; j < VECTOR_SIZE; j++) {
        values[i][j] = prng_rand_uint32() % MODULUS;
      }
    }
    sample_fixed = prng_rand_uint32() & 0x1;
  }
}

status_t handle_ml_dsa_sca_init(ujson_t *uj) {
  // Setup trigger and enable peripherals needed for the test.
  pentest_select_trigger_type(kPentestTriggerTypeSw);

  // Configure the entropy complex for OTBN. Set the reseed interval to max
  // to avoid a non-constant trigger window.
  TRY(pentest_configure_entropy_source_max_reseed_interval());

  // Initialize everything potentially needed for pentesting
  // (eg. uart, gpio, timer, csrng, edn).
  pentest_init(kPentestTriggerSourceOtbn,
               kPentestPeripheralEntropy | kPentestPeripheralIoDiv4 |
                   kPentestPeripheralOtbn | kPentestPeripheralCsrng |
                   kPentestPeripheralEdn | kPentestPeripheralHmac |
                   kPentestPeripheralKmac);

  // Initialize OTBN.
  CHECK_DIF_OK(
      dif_otbn_init(mmio_region_from_addr(TOP_EARLGREY_OTBN_BASE_ADDR), &otbn));
  
  // Disable the instruction cache and dummy instructions for better SCA
  // measurements.
  pentest_configure_cpu();

  // Read device ID and return to host.
  penetrationtest_device_id_t uj_output;
  TRY(pentest_read_device_id(uj_output.device_id));
  RESP_OK(ujson_serialize_penetrationtest_device_id_t, uj, &uj_output);

  return OK_STATUS();
}

status_t handle_ml_dsa_sca_single_ntt(ujson_t *uj) {
  uint32_t kOupVecAct[VECTOR_SIZE] = {0};
  ml_dsa_sca_data_t uj_data;
  TRY(ujson_deserialize_ml_dsa_sca_data_t(uj, &uj_data));

  // Copy uj_data.data to our fixed input vector.
  uint32_t fixed_data[VECTOR_SIZE];
  memcpy(fixed_data, uj_data.data, uj_data.data_length);

  CHECK_STATUS_OK(otbn_load_app(kOtbnAppMlDsaNtt));

  // Write input arguments.
  // CHECK_STATUS_OK(
  //     otbn_dmem_write(/*num_words=*/VECTOR_SIZE, uj_data.data, kOtbnAppMlDsaNttW));
  CHECK_STATUS_OK(
      otbn_dmem_write(/*num_words=*/VECTOR_SIZE, fixed_data, kOtbnAppMlDsaNttW));

  pentest_set_trigger_high();
  asm volatile(NOP30);
  // Call OTBN to perform operation, and wait for it to complete.
  CHECK_STATUS_OK(otbn_execute());
  otbn_busy_wait_for_done();
  pentest_set_trigger_low();

  // Read back results.
  CHECK_STATUS_OK(
      otbn_dmem_read(/*num_words=*/VECTOR_SIZE, kOtbnAppMlDsaNttW, kOupVecAct));

  // Write back last value written into the RF to validate generated data.
  ml_dsa_sca_result_t uj_output;
  uj_output.result = 0xdeadbeef;
  RESP_OK(ujson_serialize_ml_dsa_sca_result_t, uj, &uj_output);

  return OK_STATUS();
}

status_t handle_ml_dsa_sca_ntt_fvsr(ujson_t *uj) {
  ml_dsa_sca_fvsr_data_t uj_data;
  TRY(ujson_deserialize_ml_dsa_sca_fvsr_data_t(uj, &uj_data));

  // Copy uj_data.data to our fixed input vector.
  uint32_t fixed_data[VECTOR_SIZE];
  memcpy(fixed_data, uj_data.data, uj_data.data_length);

  // Load the application to OTBN.
  CHECK_STATUS_OK(otbn_load_app(kOtbnAppMlDsaNtt));

  // Generate FvsR values.
  uint32_t values[MAX_BATCH_SIZE][VECTOR_SIZE];
  generate_vec_fvsr(uj_data.iterations, fixed_data, values);

  // Set the initial value determining whether we execute
  // with random or fixed inputs.
  for (size_t it = 0; it < uj_data.iterations; it++) {
    // Write the input vector to OTBN.
    CHECK_STATUS_OK(
        otbn_dmem_write(/*num_words=*/VECTOR_SIZE, values[it], kOtbnAppMlDsaNttW));
    // Set the trigger to high and give it some time to rise.
    pentest_set_trigger_high();
    asm volatile(NOP30);
    // Call OTBN to perform the operation and wait for it to complete.
    CHECK_STATUS_OK(otbn_execute());
    otbn_busy_wait_for_done();
    // Set the trigger back to low.
    pentest_set_trigger_low();
  }

  // Write back last PRNG value to validate generated data.
  ml_dsa_sca_result_t uj_output;
  uj_output.result = values[uj_data.iterations - 1][VECTOR_SIZE - 1];
  RESP_OK(ujson_serialize_ml_dsa_sca_result_t, uj, &uj_output);
  return OK_STATUS();
}

status_t handle_ml_dsa_sca(ujson_t *uj) {
  ml_dsa_sca_subcommand_t cmd;
  TRY(ujson_deserialize_ml_dsa_sca_subcommand_t(uj, &cmd));
  switch (cmd) {
    case kMlDsaScaSubcommandInit:
      return handle_ml_dsa_sca_init(uj);
    case kMlDsaScaSubcommandSingleNtt:
      return handle_ml_dsa_sca_single_ntt(uj);
    case kMlDsaScaSubcommandNttFvsr:
      return handle_ml_dsa_sca_ntt_fvsr(uj);
    default:
      LOG_ERROR("Unrecognized ML-DSA SCA subcommand: %d", cmd);
      return INVALID_ARGUMENT();
  }
  return OK_STATUS();
}
